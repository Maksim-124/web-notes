<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Конспект «Микросетки»</title>
        <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
        <link rel="stylesheet" href="style.css">
        <link href="https://fonts.googleapis.com/css2?family=Vollkorn&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
    </head>
<body>
    <header>
        <nav-bar></nav-bar>
    </header>
    <main>
        <section>
            <h1>Конспект «Микросетки. Начало». Раздел 1</h1>
            <h2>Микросетки</h2>
            <p>Микросетки — сетки мелких элементов веб-страницы.</p>
            <p>В отличие от крупных сетки, микросетки меньше зависят от макета и больше — от содержимого. Содержимое страниц со временем может меняться. Если не учитывать этого, вёрстка сломается.</p>
            
            <h2>Отступы у ссылок</h2>
            <p>Часто ссылкам добавляют внутренние отступы, чтобы увеличить область, по которой можно кликнуть (её ещё называют активной областью). Чем проще попасть по ссылке, тем удобнее интерфейс.</p>
            <p>По умолчанию ссылки имеют строчный тип бокса. Браузер игнорирует внешние отступы по вертикали у строчных боксов, а их внутренние отступы сверху и снизу не влияют на расположение других элементов. Самый простой способ решить эту проблему — изменить у ссылок тип бокса. Например, сделать их блочными боксами:</p>
            <pre class="code-block">
.element {
  display: block;
}
</pre>

            <h2>Свойство align-items</h2>
            <p>По умолчанию грид-элементы занимают всё доступное пространство по высоте. Та такое поведение можно изменить с помощью свойства align-items. Оно задаётся грид-контейнеру и управляет выравниванием грид-элементов по вертикали.</p>
            <pre class="code-block">
.grid-container {
  display: grid;
  align-items: start;
}
</pre>
            <p>У align-items могут быть следующие значения:</p>
            <ul>
                <li><code>stretch</code> — значение по умолчанию; элементы начинаются у верхней границы и растягиваются на всю высоту.</li>
                <li><code>start</code> — элементы выстраиваются по верхной границе и, если содержимого немного, не тянутся на всю высоту;</li>
                <li><code>end</code> — элементы выстраиваются по нижней границе;</li>
                <li><code>center</code> — элементы располагаются по центру;</li>
            </ul>

            <h2>Свойство flex-wrap</h2>
            <p>Если элементам не хватает места, они могут вылезти за границы контейнера. Такое поведение называют выпадением элементов. Также говорят, что произошло переполнение.</p>
            <p>По умолчанию флекс-контейнер однострочный. Чтобы элементы не выпадали из контейнера, его делают многострочным. Для этого используют свойство flex-wrap со значением wrap.</p>
            <pre class="code-block">
.flex-container {
  display: flex;
  flex-wrap: wrap;
}
</pre>

            <h1>Конспект «Микросетки. Начало». Раздел 2</h1>
            <h2>Список на флексах</h2>
            <p>Свойство <code>justify-content</code> со значением <code>space-between</code> заставляет первый и последний элемент прижиматься к границам контейнера. Но если в ряду всего два элемента, то свободного пространства между ними может оказаться слишком много. В этом случае лучше использовать <code>margin</code>.</p>
            <p>Чтобы убрать лишний отступ у последнего элемента в ряду, используют псевдокласс <code>:nth-child</code>. Он позволяет выбрать дочерний элемент по его порядковому номеру:</p>
            <pre class="code-block">
// Выберет второй элемент с классом item
.item:nth-child(2) { ... }

// Выберет каждый второй элемент с классом item
.item:nth-child(2n) { ... }</pre>
            <p>Если не известно, какой элемент окажется в ряду последним, этот способ не сработает.</p>

            <h2>repeat</h2>
            <p>Если все колонки в грид-контейнере должны быть одинаковой ширины, то удобно использовать значение-функцию <code>repeat</code>. В скобках после <code>repeat</code> указывают количество колонок и их ширину. Значения разделяют запятой:</p>
            <pre class="code-block">
grid-template-columns: repeat(количество колонок, ширина колонки);</pre>

            <h2>auto-fit</h2>
            <p>Если количество колонки зависит от ширины контейнера, используют специальное значение <code>auto-fit</code>. Его указывают в скобках после <code>repeat</code> вместо числа колонок:</p>
            <pre class="code-block">
grid-template-columns: repeat(auto-fit, ширина колонки);</pre>

            <h2>minmax</h2>
            <p>Чтобы ширина колонок изменялась пропорционально свободному пространству в контейнере, используют значение-функцию <code>minmax</code>.</p>
            <p>Его указывают в <code>repeat</code> вместо фиксированной ширины колонок. В скобках после <code>minmax</code> задают минимальный и максимальный размеры колонки, они разделяются запятой:</p>
            <pre class="code-block">
repeat(auto-fit, minmax(минимальный размер, максимальный размер));</pre>
            <p>В <code>minmax</code> в качестве максимального значения часто используют единицу измерения <code>fr</code>. Она позволяет колонкам увеличивать ширину до тех пор, пока свободного пространства в контейнере не хватит на ещё одну колонку.</p>

            <h2>Свойства grid-column и grid-row</h2>
            <p>Чтобы растянуть элемент на несколько колонок используют свойство <code>grid-column</code>. Число после ключевого слова <code>span</code> указывает число колонок, которые элемент должен занять:</p>
            <pre class="code-block">
.element {
  grid-column: span 2;
}</pre>
            <p>Растянуть элемент на несколько рядов можно с помощью свойства <code>grid-row</code>. Ключевое слово <code>span</code> в нём означает количество рядов, которые элемент должен занять:</p>
            <pre class="code-block">
.long-element {
  grid-row: span 2;
}</pre>
            <p>Свойства <code>grid-column</code> и <code>grid-row</code> можно использовать одновременно.</p>

            <h2>Свойство grid-auto-flow</h2>
            <p>Свойство <code>grid-auto-flow</code> управляет автозаполнением грид-контейнера.</p>
            <pre class="code-block">
.grid-container {
  display: grid;
  grid-auto-flow: row;
}</pre>
            <p>Значение по умолчанию <code>row</code> говорит располагать элементы в том порядке, в котором они идут в разметке, и при необходимости создавать новые ряды.</p>
            <p>Но если указать значение <code>dense</code>, то контейнер будет заполняться так, чтобы не было пропусков:</p>
            <pre class="code-block">
.grid-container {
  display: grid;
  grid-auto-flow: dense;
}</pre>
            <p>Значение <code>dense</code> заставляет грид-контейнер заполнять пустые ячейки первым подходящим по размеру грид-элементом. При этом визуальный порядок на странице может отличаться от порядка элементов в разметке. Если порядок элементов важен, лучше это значение не использовать.</p>

            <h1>Конспект «Микросетки. Продолжение». Раздел 1</h1>
            
            <h2>Поперечная ось и свойство align-items (флекс)</h2>
            <p>Во флексах свойство <code>align-items</code> управляет расположением элементов на поперечной оси.</p>
            <p>Поперечная ось идёт перпендикулярно главной оси и по умолчанию направлена сверху вниз:</p>
            <div style="border: 1px solid #444; padding: 15px; margin: 15px 0; background: #2d2d44;">
                <img src="img/flex_scheme1.svg" alt="Схема осей флекса" style="max-width: 100%; height: auto;">
            </div>
            <p>Во флекс-контейнере свойство <code>align-items</code> может иметь следующие значения:</p>
            <ul>
                <li><code>stretch</code> — значение по умолчанию; элементы растягиваются на всю высоту поперечной оси.</li>
                <li><code>flex-start</code> — элементы сжимаются до содержимого и располагаются в начале поперечной оси (по умолчанию сверху);</li>
                <li><code>flex-end</code> — элементы сжимаются до содержимого и располагаются в конце поперечной оси (по умолчанию снизу);</li>
                <li><code>center</code> — элементы сжимаются до содержимого и располагаются по центру поперечной оси;</li>
            </ul>

            <h2>Поворот главной оси, свойство flex-direction</h2>
            <p>Главную ось поворачивают, чтобы сохранить внутри флекс-контейнера направление потока сверху вниз. За направление главной оси отвечает свойство <code>flex-direction</code>. По умолчанию у него значение <code>row</code> (ряд), но его можно изменить на <code>column</code> (колонка):</p>
            <pre class="code-block">
flex-container {
  display: flex;
  flex-direction: column;
}</pre>
            <p>В этом случае главная ось будет направлена сверху вниз, а поперечная — слева направо. В результате флекс-элементы выстроятся сверху вниз.</p>
            <p>По умолчанию флекс-элементы сжимаются по главной оси и растягиваются по поперечной. Таким образом, если главная ось направлена слева направо, то элементы сжимаются по горизонтали и растягиваются по вертикали.</p>
            <div style="border: 1px solid #444; padding: 15px; margin: 15px 0; background: #2d2d44;">
                <img src="img/flex_scheme1_1.svg" alt="Схема осей флекса" style="max-width: 100%; height: auto;">
            </div>
            <p>Если же главная ось направлена сверху вниз, то сжатие происходит по вертикали, а растяжение — по горизонтали.</p>
            <div style="border: 1px solid #444; padding: 15px; margin: 15px 0; background: #2d2d44;">
                <img src="img/flex_scheme2.svg" alt="Схема повёрнутых осей флекса" style="max-width: 100%; height: auto;">
            </div>
            <p>Получается, чтобы при повёрнутых осях выровнять элемент по горизонтали, нужно задать ему выравнивание по поперечной оси.</p>

            <h2>Свойство align-self (флекс)</h2>
            <p>Свойство <code>align-self</code> задаётся флекс-элементу и говорит, как ему расположиться на поперечной оси. Значения у этого свойства такие же, как у <code>align-items</code>: <code>stretch</code> (значение по умолчанию), <code>flex-start</code>, <code>flex-end</code> и <code>center</code>.</p>
            <pre class="code-block">
.element {
  align-self: flex-end;
}</pre>

            <h2>Свойство order</h2>
            <p>Чтобы изменить визуальный порядок элементов, удобно использовать свойство <code>order</code>. В качестве значения свойство принимает число, причём оно может быть как положительным, так и отрицаным. По умолчанию у всех элементов свойство <code>order</code> равно нулю.</p>
            <pre class="code-block">
.element {
  order: 5;
}</pre>
            <p>Элементы выстраиваются от меньшего значения <code>order</code> к большему. Если у нескольких элементов одинаковое значение, используется их порядок в разметке.</p>
            <p>Свойство <code>order</code> работает только в грид- и флекс-контейнерах.</p>

            <h2>Отступы у флекс-элементов</h2>
            <p>Внешние отступы у соседних флекс-элементов складываются.</p>
            <div style="border: 1px solid #444; padding: 15px; margin: 15px 0; background: #2d2d44;">
                <img src="img/scheme_flex-grid01.svg" alt="Внешние отступы соседних элементов" style="max-width: 100%; height: auto;">
            </div>
            <p>Чтобы не запутаться и получить именно те размеры, которые указаны в макете, верстальщики добавляют элементам внешние отступы только с одной стороны. Часто внешние отступы задают в направлении потока. Если элементы выстроены горизонтально, то отступ задают справа, а у последнего элемента обнуляют:</p>
            <div style="border: 1px solid #444; padding: 15px; margin: 15px 0; background: #2d2d44;">
                <img src="img/scheme_flex-grid02.svg" alt="Внешние отступы, горизонтальный поток" style="max-width: 100%; height: auto;">
            </div>
            <p>Если элементы выстроены вертикально, то отступ добавляют снизу. Исключение — самый последний элемент (например, подвал страницы), ему при необходимости задают отступ сверху:</p>
            <div style="border: 1px solid #444; padding: 15px; margin: 15px 0; background: #2d2d44;">
                <img src="img/scheme_flex-grid03.svg" alt="Внешние отступы, вертикальный поток" style="max-width: 100%; height: auto;">
            </div>
            <p>В этом случае, даже если изменить порядок секций, они не слипнутся, а между ними не появятся лишние отступы.</p>

            <h2>Уменьшение изображений с сохранением пропорций</h2>
            <p>Если использовать картинку большего размера, чем родительский элемент, она выпадет из контейнера. Чтобы не допускать подобного, верстальщики добавляют картинкам такие стили:</p>
            <pre class="code-block">
img {
  max-width: 100%;
  height: auto;
}</pre>
            <p>Свойство <code>max-width</code> задаёт максимальную ширину, а значение <code>100%</code> говорит, что элемент не должен становиться больше ширины родителя.</p>
            <p>Свойство <code>height</code> задаёт высоту элемента. Значение <code>auto</code> используют, чтобы изображение не деформировалось и сохраняло свои пропорции. Если его не указать, то будет использовано значение атрибута <code>height</code> из разметки, и картинка, скорее всего, исказится.</p>
            <p>Этот способ работает, потому что у CSS-свойств <code>max-width</code> и <code>height</code> приоритет выше, чем у атрибутов <code>width</code> и <code>height</code> в разметке.</p>

            <h1>Конспект «Микросетки. Продолжение». Раздел 2</h1>
            
            <h2>Грид-области</h2>
            <p>Грид-областью называют часть сетки грид-контейнера, у которой есть имя. Имя области придумывает сам разработчик. Оно должно начинаться с буквы и может включать цифры, дефис и знак подчёркивания. Например: <code>header</code>, <code>section-2</code>, <code>user_avatar</code>. Следует выбирать такие имена, которые описывают содержимое области.</p>
            
            <p>Чтобы описать структуру грида с помощью областей, используют свойство <code>grid-template-areas</code>. В нём указывают имена грид-областей. При этом каждый ряд оборачивают в кавычки, а колонки разделяют пробелом.</p>
            
            <pre class="code-block">
.card {
  display: grid;
  grid-template-areas: "title price";
}</pre>
            
            <p>В <code>grid-template-areas</code> можно указать сколько угодно рядов. При этом в кавычки оборачивают <strong>каждый</strong> ряд, но точка с запятой ставится только после последнего ряда! Для большей наглядности ряды записывают друг под другом:</p>
            
            <pre class="code-block">
grid-template-areas: "title price"
                     "options description";</pre>
            
            <p>Однако просто описать шаблон недостаточно, ведь браузер не знает, какие элементы мы имеем в виду. Чтобы связать имя области с соответствующим грид-элементом, используют свойство <code>grid-area</code>. Обратите внимание, в <code>grid-area</code> кавычки не нужны!</p>
            
            <pre class="code-block">
.title {
  grid-area: title;
}</pre>
            
            <h2>Как растянуть грид-область</h2>
            <p>Если требуется растянуть область на несколько колонок, её имя повторяют нужное число раз:</p>
            
            <pre class="code-block">
grid-template-areas: "title title price";</pre>
            
            <p>Чтобы растянуть область на несколько рядов, достаточно повторить её имя в разных рядах:</p>
            
            <pre class="code-block">
grid-template-areas: "options description"
                     "options disclaimer";</pre>
            
            <h2>Ограничения при использовании грид-областей</h2>
            <p>Грид-области должны быть прямоугольными и непрерывными.</p>
            
            <pre class="code-block">
// Такой код не сработает
grid-template-areas: "logo main"
                     "main main";

// Такой – тоже
grid-template-areas: "nav logo nav";</pre>
            
            <p>При описании шаблона количество колонок в каждом ряду должно быть одинаковым:</p>
            
            <pre class="code-block">
// Такой код не сработает
grid-template-areas: "logo nav"
                     "aside main banner"
                     "footer";</pre>
            
            <p>Если задать неправильное значение <code>grid-template-areas</code>, браузер его проигнорирует, и вёрстка может сломаться.</p>
            
            <p>Имена областей <em>в одном контейнере</em> должны быть уникальными. Если задать одинаковое имя нескольким элементам, они наложатся друг на друга. По этой причине грид-области не подойдут, например, для списка карточек, особенно если количество этих карточек неизвестно заранее.</p>
            
            <h2>Свойство align-self (грид)</h2>
            <p>Свойство <code>align-self</code> задаёт выравнивание по вертикали <em>одному элементу</em>. Значения <code>align-self</code> принимает те же, что и <code>align-items</code>: <code>stretch</code> (значение по умолчанию), <code>start</code>, <code>end</code> и <code>center</code>.</p>
            
            <pre class="code-block">
.element {
  align-self: start;
}</pre>
            
            <h2>Свойство justify-self</h2>
            <p>Свойство <code>justify-self</code> отвечает за выравнивание отдельного элемента по горизонтали:</p>
            
            <pre class="code-block">
.element {
  justify-self: start;
}</pre>
            
            <p>Это свойство принимает следующие значения:</p>
            <ul>
                <li><code>stretch</code> — значение по умолчанию; элемент занимает всё пространство по ширине.</li>
                <li><code>start</code> — элемент сжимается до содержимого и прижимается к левой границе.</li>
                <li><code>end</code> — элемент сжимается до содержимого и прижимается к правой границе.</li>
                <li><code>center</code> — элемент сжимается до содержимого и располагается по центру.</li>
            </ul>

        </section>
    </main>

    <!-- Скрипт заменяющие цвет текста внутри мнемоник родительско элемента class="code-block" на синий  -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const codeBlocks = document.querySelectorAll(".code-block");
            const htmlTagRegex = /(<\/?[a-zA-Z0-9\-]+(?:\s+[a-zA-Z\-]+=("|')[^<>]*("|'))*\s*>)/g;
            codeBlocks.forEach(codeBlock => {
                let html = codeBlock.innerHTML;
                html = html.replace(htmlTagRegex, '<span class="html-tag">$1</span>');
                codeBlock.innerHTML = html;
            });
        });
    </script>
    <script src="nav-bar.js"></script>
    <a href="#">Наверх</a>
</body>
</html>